#!/usr/bin/env python3
"""
Bundled Python file generated by Python File Bundler
Source files: connect_db.py, analyze.py, combine.py, inputs.py, match_utils.py, matcher.py, matcher_ui.py, secure.py, sensor.py, share.py, summary.py, main.py
"""

import json
import os
import random
import re
import secrets
import smtplib
import string
import threading
import tkinter as tk
from argon2 import PasswordHasher
from collections import defaultdict
from datetime import datetime
from dotenv import load_dotenv
from email.mime.text import MIMEText
from itertools import zip_longest
from nava import play
from pymongo.mongo_client import MongoClient
from pymongo.server_api import ServerApi
from random import shuffle
from tkinter import ttk
from tksheet import Sheet



# Content from connect_db.py
load_dotenv()
uri = os.environ['MONGO_URI'].replace('<db_password>', os.environ['MONGO_PW'])
client = MongoClient(uri, server_api=ServerApi('1'))
try:
    client.admin.command('ping')
    print('Pinged your deployment. You successfully connected to MongoDB!')
    users = client['SSHS-Matcher']['User']
    rooms = client['SSHS-Matcher']['Room']
except Exception as e:
    print(e)


# Content from analyze.py
class analyze:

    def __init__(self):
        pass


# Content from combine.py
def dupli(start1, end1, start2, end2):
    return start1 <= start2 < end1 or start2 <= start1 < end2

def combine():
    data = json.load(open('./patterns.json', 'r'))
    for key, values in data[1].items():
        for value in values:
            for v in data[0].get(key, {}):
                if dupli(value['start'], value['end'], v['start'], v['end']):
                    data[0][key].remove(value)
                    break
    return data


# Content from inputs.py
ids = [1, 2, 3, 4, 5]
'sensors = [Sensor(i) for i in ids]\n# 각각의 센서로부터 데이터를 동시에 받기 위한 thread를 담은 리스트\nthreads = [threading.Thread(sensor.listen) for sensor in sensors]\n\nfor thread in threads:\n    thread.start()\n'


# Content from match_utils.py
def get_num(user):
    res = 0
    if user['gender'] == 'F':
        res += 3
    res += user['grade'] - 1
    return res

def basic_filtering(data1, data2):
    gender = data1['gender'] == data2['gender']
    grade = data1['grade'] == data2['grade']
    return gender and grade


# Content from matcher.py
pattern_weights = {'wake_up': 2.5, 'sleep': 3, 'early_bird': 2, 'air': 1, 'light_off': 2.7}
time_pat = ['wake_up', 'sleep', 'air']
time_range_pat = ['study']
likely_pat = ['early_bird']
off_pat = 'light_off'

def calc_diff(p1, p2, pattern):
    pat1 = p1[pattern]
    pat2 = p2[pattern]
    if pattern in time_pat:
        diff = datetime.strptime(pat2, '%H:%M:%S') - datetime.strptime(pat1, '%H:%M:%S')
        d = diff.seconds / 60
        return abs(d)
    elif pattern == off_pat:
        diff = datetime.strptime(p2['sleep'], '%H:%M:%S') - datetime.strptime(p1['sleep'], '%H:%M:%S')
        if diff.seconds > 0:
            return (pat1 ** 2 + pat2) / 2
        elif diff.seconds < 0:
            return (pat1 + pat2 ** 2) / 2
        else:
            return (pat1 ** 2 + pat2 ** 2) / 2
    elif pattern in likely_pat:
        return abs(pat1 - pat2)
    raise Exception('Invalid pattern')

def score(data1, data2) -> float:
    sco = 0
    for pattern, weight in pattern_weights.items():
        sco += calc_diff(data1['summary'], data2['summary'], pattern) * weight
    return sco

def filtering(data1, data2):
    wake_diff = calc_diff(data1['summary'], data2['summary'], 'wake_up')
    sleep_diff = calc_diff(data1['summary'], data2['summary'], 'sleep')
    early = calc_diff(data1['summary'], data2['summary'], 'early_bird')
    sleep_wake = wake_diff <= 30 and sleep_diff <= 30 or (wake_diff <= 15 and sleep_diff <= 60) or (wake_diff <= 60 and sleep_diff <= 15) or (wake_diff <= 60 and sleep_diff <= 60 and (early >= 0.5))
    return sleep_wake and basic_filtering(data1, data2)

def gen_candidates():
    data1 = list(users.find({'gender': 'M', 'grade': 1}))
    data2 = list(users.find({'gender': 'M', 'grade': 2}))
    data3 = list(users.find({'gender': 'M', 'grade': 3}))
    data4 = list(users.find({'gender': 'F', 'grade': 1}))
    data5 = list(users.find({'gender': 'F', 'grade': 2}))
    data6 = list(users.find({'gender': 'F', 'grade': 3}))
    datas = [data1, data2, data3, data4, data5, data6]
    two_pairs = []
    three_pairs = []
    for data in datas:
        for i, person1 in enumerate(data):
            for j in range(i + 1, len(data)):
                person2 = data[j]
                if filtering(person1, person2):
                    if len(data) % 3 != 0:
                        two_pairs.append((person1, person2))
                    for k in range(j + 1, len(data)):
                        person3 = data[k]
                        if filtering(person3, person2) and filtering(person3, person1):
                            three_pairs.append((person1, person2, person3))
    return (two_pairs, three_pairs)

def greedy_matching() -> list[tuple[str, str, str]]:
    data1 = list(users.find({'gender': 'M', 'grade': 1}))
    data2 = list(users.find({'gender': 'M', 'grade': 2}))
    data3 = list(users.find({'gender': 'M', 'grade': 3}))
    data4 = list(users.find({'gender': 'F', 'grade': 1}))
    data5 = list(users.find({'gender': 'F', 'grade': 2}))
    data6 = list(users.find({'gender': 'F', 'grade': 3}))
    shuffle(data1)
    shuffle(data2)
    shuffle(data3)
    shuffle(data4)
    shuffle(data5)
    shuffle(data6)
    datas = [data1, data2, data3, data4, data5, data6]
    students = list(users.find())
    'for student in students:\n        summarize(student)'
    print('Generating candidates')
    two_pairs, three_pairs = gen_candidates()
    print('Finished generation')
    scores = defaultdict(list)
    paired_result = []
    need_twos = [int(len(data) % 3 == 2) if len(data) % 3 != 1 else 2 for data in datas]
    for pair in three_pairs:
        score1 = score(pair[0], pair[1])
        score2 = score(pair[1], pair[2])
        score3 = score(pair[2], pair[0])
        scores[(score1 + score2 + score3) / 3].append(pair)
    for pair in two_pairs:
        score1 = score(pair[0], pair[1])
        scores[score1].append(pair)
    for sco in sorted(scores.keys(), reverse=True):
        for pair in scores[sco]:
            ind = get_num(pair[0])
            if any((student not in students for student in pair)) or (need_twos[ind] == 0 and len(pair) == 2):
                continue
            if len(pair) == 2:
                need_twos[ind] -= 1
            paired_result.append(pair)
            for student in pair:
                students.remove(student)
    unmatched_pairs = defaultdict(list)
    for i, student1 in enumerate(students):
        for j in range(i + 1, len(students)):
            student2 = students[j]
            if not basic_filtering(student1, student2):
                continue
            score1 = score(student1, student2)
            if need_twos[get_num(student1)] > 0:
                unmatched_pairs[score1].append((student1, student2))
            for k in range(j + 1, len(students)):
                student3 = students[k]
                if not basic_filtering(student1, student3) or not basic_filtering(student2, student3):
                    continue
                score2 = score(student2, student3)
                score3 = score(student3, student1)
                unmatched_pairs[(score1 + score2 + score3) / 3].append((student1, student2, student3))
        unmatched_pairs[0].append((student1,))
    for sco in sorted(unmatched_pairs.keys(), reverse=True):
        for pair in unmatched_pairs[sco]:
            ind = get_num(pair[0])
            if any((student not in students for student in pair)) or (need_twos[ind] == 0 and len(pair) == 2):
                continue
            if len(pair) == 2:
                need_twos[ind] -= 1
            paired_result.append(pair)
            for student in pair:
                students.remove(student)
    return paired_result


# Content from matcher_ui.py
root = None

def start_matching():
    play('./sounds/button.mp3')
    matched = greedy_matching()
    print('Greedy matching finished')
    shuffle(matched)
    print(len(matched))
    for pair in matched:
        match get_num(pair[0]):
            case 0:
                room = rooms.find_one({'floor': 5, 'reset': False})
            case 1:
                room = rooms.find_one({'floor': 4, 'reset': False})
            case 2:
                room = rooms.find_one({'floor': 3, 'reset': False})
            case 3 | 4 | 5:
                room = rooms.find_one({'floor': 2, 'reset': False})
        rooms.update_one(room, {'$set': {'reset': True, 'students': pair}})
    print('Each pair got their room')
    for room in rooms.find():
        if not room['reset']:
            rooms.update_one(room, {'$set': {'students': tuple()}})
        else:
            rooms.update_one(room, {'$set': {'reset': False}})
    print('Matching finished')

def matcher_ui(rt):
    global root
    root = rt
    match_button = ttk.Button(root, text='새로운 룸메이트 매칭?', command=start_matching)
    match_button.pack()
    rooms_sheet = Sheet(root, data=[[room['number'], *[student['username'] for student in room['students']]] for room in rooms.find()], height=520, width=200)
    rooms_sheet.pack()


# Content from secure.py
load_dotenv()
charset = set('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_')

def safety_check(pw: str):
    return len(pw) >= 8 and sum((int(c.isupper()) for c in pw)) >= 2 and (sum((int(c.islower()) for c in pw)) >= 2) and (sum((int(c.isdigit()) for c in pw)) >= 2)

def valid_id(id: str):
    return len(set(id) - charset) == 0

def email_format_check(email: str):
    last = datetime.now().year % 100
    if datetime.today().strftime('%m-%d') < '03-01':
        last -= 1
    if re.fullmatch(f'({last - 3}|{last - 2}|{last - 1}|{last})' + '\\d{3}@sshs.hs.kr', email):
        return last - int(email[:2]) + 1
    return -1
N = 8
possible_chars = string.ascii_letters + string.digits

def gen_code():
    return ''.join((secrets.choice(possible_chars) for _ in range(N)))
subject = 'THE PATTERN 인증 코드'
sender = os.environ['NAVER_MAIL']
password = os.environ['NAVER_PW']

def send_email(receipt):
    code = gen_code()
    msg = MIMEText(code)
    msg['Subject'] = subject
    msg['From'] = sender
    msg['To'] = receipt
    with smtplib.SMTP_SSL('smtp.naver.com', 465) as smtp_server:
        smtp_server.login(sender, password)
        smtp_server.sendmail(sender, receipt, msg.as_string())
    return code


# Content from sensor.py
class Sensor:

    def __init__(self, sensor_id, user):
        self.id = sensor_id
        self.user = user

    def input(self):
        if self.id == 0:
            return random.randint(1, 10)

    def listen(self):
        """while True:
        if random.random() < 0.01:
            with open("users.json", 'r+') as f:
                json.load(f)[self.user]["patterns"].append()# something...)"""
        pass


# Content from share.py
ph = PasswordHasher()
root = None
alpha = 'ABCD'

def share(username):
    global root
    user = users.find_one({'username': username})
    me_sheet = Sheet(root, data=[[username], *[[' '.join(pattern)] for pattern in user['patterns']]], height=520, width=200)
    me_sheet.enable_bindings('all')
    me_sheet.pack()
    roommates = user['roommate']
    roommate_patterns = zip_longest(*[list(map(lambda x: ' '.join(x), users.find_one({'username': roommate})['patterns'])) for roommate in roommates], fillvalue='')
    roommate_patterns = list(roommate_patterns)
    roommate_sheet = Sheet(root, data=[roommates, *roommate_patterns], height=520, width=200 * len(roommates))
    roommate_sheet.pack()

def verify_code(email, username, pw, code_var, code, widgets):
    for widget in widgets:
        widget.destroy()
    if code_var != code:
        wrong_label = ttk.Label(root, text='인증 코드가 틀렸습니다.')
        wrong_label.pack()
    else:
        add_user(email, username, pw, widgets)
    start(root)

def verify_info(email, username, pw, widgets):
    play('./sounds/button.mp3')
    message = '이메일 또는 아이디가 중복되어 있습니다.'
    if not safety_check(pw.get()):
        message = '비밀번호가 규칙에 맞지 않습니다.'
    else:
        gra = email_format_check(email.get())
        if gra == -1:
            message = '이메일 형식이 맞지 않거나 재학생이 아닙니다.'
        else:
            code = send_email(email.get())
            for widget in widgets:
                widget.destroy()
            code_var = tk.StringVar(root)
            code_label = ttk.Label(root, text='인증 코드를 입력해주세요.')
            code_label.pack()
            code_entry = ttk.Entry(root, textvariable=code_var)
            code_entry.pack()
            code_button = ttk.Button(root, text='인증', command=lambda: verify_code(email, username, pw, code_var.get(), code, [code_label, code_entry, code_button, *widgets]))
            code_button.pack()
            return
    for widget in widgets:
        widget.pack()
    wrong_label = ttk.Label(root, text=message)
    wrong_label.pack()

def add_user(email, username, pw):
    email_not_found = not users.find_one({'email': email.get()})
    username_not_found = not users.find_one({'username': username.get()})
    if username_not_found and email_not_found:
        users.insert_one({'username': username.get(), 'email': email.get(), 'pw': ph.hash(pw.get()), 'patterns': [], 'roommate': [], 'summary': {'wake_up': '07:00:00', 'sleep': '01:00:00', 'early_bird': 0, 'light_off': [0, 0], 'air': '12:40:00', 'study': ['00:00:00-01:00:00', '23:00:00-00:00:00']}, 'gender': 'M', 'grade': 1, 'room': 500})
        return
    raise Exception('Invalid username or email')

def verify(username, pw, widgets):
    play('./sounds/button.mp3')
    found = users.find_one({'username': username.get()})
    if found and ph.verify(found['pw'], pw.get()):
        for widget in widgets:
            widget.destroy()
        share(username.get())
    else:
        wrong_label = ttk.Label(root, text='비밀번호나 아이디가 틀렸습니다.')
        wrong_label.pack()

def login(widgets):
    for widget in widgets:
        widget.destroy()
    username = tk.StringVar(root)
    pw = tk.StringVar(root)
    root.title('패턴 공유 플랫폼 - 로그인')
    username_label = ttk.Label(root, text='아이디')
    username_label.pack()
    username_entry = ttk.Entry(root, textvariable=username)
    username_entry.pack()
    pw_label = ttk.Label(root, text='비밀번호')
    pw_label.pack()
    pw_entry = ttk.Entry(root, textvariable=pw)
    pw_entry.pack()
    login_button = ttk.Button(root, text='로그인', command=lambda: verify(username, pw, [username_label, username_entry, pw_label, pw_entry, login_button]))
    login_button.pack()

def signup(widgets):
    for widget in widgets:
        widget.pack_forget()
    email = tk.StringVar(root)
    username = tk.StringVar(root)
    pw = tk.StringVar(root)
    root.title('패턴 공유 플랫폼 - 회원가입')
    email_label = ttk.Label(root, text='이메일')
    email_label.pack()
    email_entry = ttk.Entry(root, textvariable=email)
    email_entry.pack()
    username_label = ttk.Label(root, text='아이디')
    username_label.pack()
    username_entry = ttk.Entry(root, textvariable=username)
    username_entry.pack()
    pw_label = ttk.Label(root, text='비밀번호')
    pw_label.pack()
    pw_entry = ttk.Entry(root, textvariable=pw)
    pw_entry.pack()
    login_button = ttk.Button(root, text='회원가입', command=lambda: verify_info(email, username, pw, [email_label, email_entry, username_label, username_entry, pw_label, pw_entry, login_button]))
    login_button.pack()

def start(rt):
    global root
    root = rt
    login_button = ttk.Button(root, text='로그인', command=lambda: login([login_button, signup_button]))
    login_button.pack()
    signup_button = ttk.Button(root, text='회원가입', command=lambda: signup([login_button, signup_button]))
    signup_button.pack()


# Content from summary.py
def summarize(player: str, data):
    times = defaultdict(list)
    res = defaultdict(list)
    for pattern in data[player]['patterns']:
        match pattern[0]:
            case 'wake_up' | 'sleep' | 'air':
                time = datetime.strptime(pattern[1], '%H:%M:%S')
                times[pattern[0]].append(time.seconds)
            case 'early_bird':
                times[pattern[0]].append(pattern[1])
    for key, arr in times.items():
        match key:
            case 'wake_up' | 'sleep' | 'air':
                value = sum(arr) / len(arr)
                hour = value // 3600
                minute = value % 3600 // 60
                second = value % 60
                res[key] = f'{hour:02d}:{minute:02d}{second:02d}'
            case 'early_bird' | 'light_off':
                res[key] = arr[0] / arr[1]
    return res


# Content from main.py
try:
    root = tk.Tk()
    root.title('THE PATTERN')
    root.iconbitmap('./images/logo.ico')
    imgtk = tk.PhotoImage(file='./images/logo.png')
    panel = ttk.Label(root, image=imgtk)
    panel.pack()
    mode = tk.StringVar(root)

    def check():
        global mode
        panel.pack_forget()
        mode_label.pack_forget()
        mode_options.pack_forget()
        mode_select.pack_forget()
        mode_button.pack_forget()
        match mode.get():
            case '공유 플랫폼':
                start(root)
            case '매칭 시스템':
                matcher_ui(root)
            case _:
                raise Exception(f'Unknown mode {mode.get()}')

    def show():
        mode_label.config(text=mode.get())
    modes = ['매칭 시스템', '공유 플랫폼']
    mode = tk.StringVar(value=modes[0])
    mode_options = ttk.OptionMenu(root, mode, *modes)
    mode_options.pack()
    mode_select = ttk.Button(root, text='모드 선택', command=show)
    mode_select.pack()
    mode_label = ttk.Label(root, text=' ')
    mode_label.pack()
    mode_button = ttk.Button(root, text='확인', command=check)
    mode_button.pack()
    root.geometry('500x500')
    root.mainloop()
except BaseException as e:
    root.destory()
    print(e)
